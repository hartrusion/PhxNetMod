# This workflow will build a Java project with Ant and upload the JAR artifact.
# After a successful run it will delete older artifacts with the same artifact name,
# so only the newest "Package" artifact remains.
# Note: To allow deleting artifacts the workflow needs an elevated permission for actions (write).
name: Java CI

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

# Allow this workflow to delete older artifacts via the GITHUB_TOKEN
permissions:
  actions: write
  contents: read

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Install ant and unzip
        run: |
          sudo apt-get update
          sudo apt-get install -y ant unzip jq

      - name: Prepare lib directory
        run: mkdir -p lib

      - name: Find latest Utils artifact (from ${{ github.event.inputs.utils_repo }})
        id: find_artifact
        env:
          UTILS_REPO: ${{ github.event.inputs.utils_repo }}
          TOKEN: ${{ secrets.UTILS_TOKEN || github.token }}
        run: |
          set -e
          echo "Searching artifacts in repo: $UTILS_REPO"
          API="https://api.github.com/repos/hartrusion/Utils/actions/artifacts"
          # get first non-expired artifact (sorted by returned order, usually newest first)
          ARTIFACT_ID=$(curl -s -H "Authorization: token ${TOKEN}" "${API}" | jq -r '.artifacts[] | select(.expired==false) | .id' | head -n1)
          if [ -z "$ARTIFACT_ID" ] || [ "$ARTIFACT_ID" = "null" ]; then
            echo "No artifact found in Utils"
            exit 1
          fi
          echo "artifact_id=${ARTIFACT_ID}" >> $GITHUB_OUTPUT
          echo "Found artifact id: $ARTIFACT_ID"

      - name: Download and extract Utils artifact
        env:
          UTILS_REPO: ${{ github.event.inputs.utils_repo }}
          TOKEN: ${{ secrets.UTILS_TOKEN || github.token }}
        run: |
          set -e
          ART_ID=${{ steps.find_artifact.outputs.artifact_id }}
          echo "Downloading artifact $ART_ID from hartrusion/Utils..."
          ZIP_URL="https://api.github.com/repos/hartrusion/Utils/actions/artifacts/${ART_ID}/zip"
          curl -L -H "Authorization: token ${TOKEN}" -o utils_art.zip "$ZIP_URL"
          # extract any .jar files into lib/
          unzip -j -o utils_art.zip '*.jar' -d lib || true
          ls -la lib

      - name: Download TestNG 6.14.3 into lib/
        run: |
          mkdir -p lib
          curl -sSL -o lib/testng-6.14.3.jar https://repo1.maven.org/maven2/org/testng/testng/6.14.3/testng-6.14.3.jar
          echo "Downloaded testng to lib/testng-6.14.3.jar"
          ls -la lib

      - name: Run Ant (compile, tests, package)
        run: |
          ant -Dtestng.jar=lib/testng-6.14.3.jar
        
  probe-artifacts:
    needs: build
    runs-on: ubuntu-latest
    outputs:
      has_artifacts: ${{ steps.check.outputs.has_artifacts }}
    steps:
      - name: Check for artifacts named "Package"
        id: check
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          API_URL: https://api.github.com/repos/${{ github.repository }}
          ARTIFACT_NAME: Package
        run: |
          set -euo pipefail
          # List artifacts (first page). If you expect >100 artifacts, implement paging.
          resp=$(curl -s -H "Authorization: token $GITHUB_TOKEN" "$API_URL/actions/artifacts?per_page=100")
          # Count artifacts with the desired name
          count=$(echo "$resp" | jq -r '.artifacts[] | select(.name == env.ARTIFACT_NAME) | .id' | wc -l)
          if [ "$count" -gt 0 ]; then
            echo "Found $count artifact(s) named '$ARTIFACT_NAME'."
            echo "has_artifacts=true" >> $GITHUB_OUTPUT
          else
            echo "No artifacts named '$ARTIFACT_NAME' found."
            echo "has_artifacts=false" >> $GITHUB_OUTPUT
          fi
          
  cleanup:
    needs: probe-artifacts
    # run only if probe found artifacts; otherwise the job is SKIPPED (grey in UI)
    if: needs.probe-artifacts.outputs.has_artifacts == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Delete older 'Package' artifacts (keep only the newest)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          API_URL: https://api.github.com/repos/${{ github.repository }}
          ARTIFACT_NAME: Package
        run: |
          set -euo pipefail
          echo "Listing artifacts..."
          resp=$(curl -s -H "Authorization: token $GITHUB_TOKEN" "$API_URL/actions/artifacts?per_page=100")
          # produce lines: created_at id, sorted newest first
          artifacts=$(echo "$resp" | jq -r '.artifacts[] | select(.name == env.ARTIFACT_NAME) | "\(.created_at) \(.id)"' | sort -r)
          echo "Matched artifacts (newest first):"
          echo "$artifacts"

          ids_to_delete=$(echo "$artifacts" | tail -n +2 | awk '{print $2}')
          if [ -z "$ids_to_delete" ]; then
            echo "Only newest artifact exists â€” nothing to delete."
            exit 0
          fi

          for id in $ids_to_delete; do
            echo "Deleting artifact id=$id ..."
            http_status=$(curl -s -o /dev/null -w "%{http_code}" -X DELETE -H "Authorization: token $GITHUB_TOKEN" "$API_URL/actions/artifacts/$id")
            if [ "$http_status" -ge 200 ] && [ "$http_status" -lt 300 ]; then
              echo "Deleted artifact id=$id (status $http_status)"
            else
              echo "Failed to delete artifact id=$id (status $http_status)"
              exit 1
            fi
          done
          echo "Old artifacts removed."
