/*
 * The MIT License
 *
 * Copyright 2026 Viktor Alexander Hartung.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package com.hartrusion.modeling.assemblies;

import com.hartrusion.modeling.phasedfluid.PhasedFlowSource;
import com.hartrusion.modeling.phasedfluid.PhasedNoMassExchangerResistance;
import com.hartrusion.modeling.phasedfluid.PhasedNode;
import com.hartrusion.modeling.phasedfluid.PhasedOrigin;
import com.hartrusion.modeling.phasedfluid.PhasedPropertiesWater;
import com.hartrusion.modeling.solvers.DomainAnalogySolver;
import com.hartrusion.util.SimpleLogOut;
import static org.testng.Assert.*;
import org.testng.annotations.AfterClass;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.Test;

/**
 *
 * @author Viktor Alexander Hartung
 */
public class PhasedExchangerNoMassTest {
    
        /*
    *       ------                ------
    *      _|_   |               _|_   |
    *   priSink  |            secSink  |
    *            o                     o      Nodes are generated by the 
    *            |                     |      assembly class, here: out nodes
    *           ===                   ===
    *           | |                   | |
    *           | | Primary Side      | | Secondary Side
    *           | |                   | |
    *           | |- Connection via  -| |
    *           | |-both phsd handlers| |
    *           | |                   | |
    *           | |                   | |
    *           ===                   ===
    *            |                     |
    *            o                     o - also part of assembly class (in node)
    *            |                     |
    *           (-) priFlow           (-) secFlow
    *            |                     |
    *            o priSrcNode          o secSrcNode
    *            |                     |
    *            |                     |
    *           _|_ priSrc            _|_ secSrc
     */
    private PhasedExchangerNoMass instance;
    private PhasedPropertiesWater water = new PhasedPropertiesWater();

    private PhasedOrigin priSrc, secSrc, priSink, secSink;
    private PhasedNode priSrcNode, secSrcNode;
    private PhasedFlowSource priFlow, secFlow;

    private DomainAnalogySolver solver;

    @BeforeClass
    public static void setUpClass() throws Exception {
        // Keep Log out clean during test run
        SimpleLogOut.configureLoggingWarningsOnly();
    }

    @BeforeMethod
    public void setUpMethod() throws Exception {
        // Set up the network as displayed on the comment and set up a solver.
        instance = new PhasedExchangerNoMass(water);
        priSrc = new PhasedOrigin();
        secSrc = new PhasedOrigin();
        priSink = new PhasedOrigin();
        secSink = new PhasedOrigin();
        priSrcNode = new PhasedNode();
        secSrcNode = new PhasedNode();
        priFlow = new PhasedFlowSource();
        secFlow = new PhasedFlowSource();

        instance.initGenerateNodes();
        instance.initName("HeatExchanger");
        priSrc.setName("priSrc");
        secSrc.setName("secSrc");
        priSink.setName("priSink");
        secSink.setName("secSink");
        priSrcNode.setName("priSrcNode");
        secSrcNode.setName("secSrcNode");
        priFlow.setName("priFlow");
        secFlow.setName("secFlow");

        // Set NTU value
        instance.initCharacteristic(0.8);

        // Connect elements:
        priSrc.connectToVia(priFlow, priSrcNode);
        priFlow.connectTo(instance.getPhasedNode(
                HeatExchangerNoMass.PRIMARY_IN));
        priSink.connectTo(instance.getPhasedNode(
                HeatExchangerNoMass.PRIMARY_OUT));
        secSrc.connectToVia(secFlow, secSrcNode);
        secFlow.connectTo(instance.getPhasedNode(
                HeatExchangerNoMass.SECONDARY_IN));
        secSink.connectTo(instance.getPhasedNode(
                HeatExchangerNoMass.SECONDARY_OUT));

        // Set up solver
        solver = new DomainAnalogySolver();
        solver.addNetwork(priSrcNode);
    }

    @AfterMethod
    public void tearDownMethod() throws Exception {
        instance = null;
        priSrc = null;
        secSrc = null;
        priSink = null;
        secSink = null;
        priSrcNode = null;
        secSrcNode = null;
        priFlow = null;
        secFlow = null;
        solver = null;
    }
    
    /**
     * No flow: Nothing happens.
     */
    @Test
    public void testZeroFlow() {
        priFlow.setFlow(0.0);
        secFlow.setFlow(0.0);

        solver.prepareCalculation();
        solver.doCalculation();

        assertEquals(priSink.isCalculationFinished(), true);
        assertEquals(secSink.isCalculationFinished(), true);
        assertEquals(instance.getPrimarySide().isCalculationFinished(), true);
        assertEquals(instance.getSecondarySide().isCalculationFinished(), true);
        assertEquals(instance.getPrimarySide().getFlow(), 0.0, 1e-12);
        assertEquals(instance.getSecondarySide().getFlow(), 0.0, 1e-12);
    }
    
    /**
     * Two streams with same temperature and mass flow
     */
    @Test
    public void equalFlowsAndTemperatures() {
        double heatEnergy = 300 * water.getSpecificHeatCapacity();
        priFlow.setFlow(20.0);
        priSrc.setOriginHeatEnergy(heatEnergy);
        secFlow.setFlow(20.0);
        secSrc.setOriginHeatEnergy(heatEnergy);

        solver.prepareCalculation();
        solver.doCalculation();

        assertEquals(priSink.isCalculationFinished(), true);
        assertEquals(secSink.isCalculationFinished(), true);
        assertEquals(instance.getPrimarySide().isCalculationFinished(), true);
        assertEquals(instance.getSecondarySide().isCalculationFinished(), true);

        // Flow rates and temperature must be same as before
        assertEquals(instance.getPrimarySide().getFlow(), 20.0, 1e-12);
        assertEquals(instance.getSecondarySide().getFlow(), 20.0, 1e-12);
        assertEquals(instance.getPhasedNode(PhasedExchangerNoMass.PRIMARY_IN)
                .getHeatEnergy(), heatEnergy, 1e-12);
        assertEquals(instance.getPhasedNode(PhasedExchangerNoMass.SECONDARY_OUT)
                .getHeatEnergy(), heatEnergy, 1e-12);
        assertEquals(secSink.isCalculationFinished(), true);
    }
}
