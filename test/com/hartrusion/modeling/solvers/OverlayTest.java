/*
 * The MIT License
 *
 * Copyright 2025 Viktor Alexander Hartung.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package com.hartrusion.modeling.solvers;

import com.hartrusion.modeling.PhysicalDomain;
import com.hartrusion.modeling.general.ClosedOrigin;
import com.hartrusion.modeling.general.EffortSource;
import com.hartrusion.modeling.general.GeneralNode;
import com.hartrusion.modeling.general.LinearDissipator;
import com.hartrusion.util.SimpleLogOut;
import static org.testng.Assert.*;

import org.testng.annotations.BeforeClass;
import org.testng.annotations.Test;

/**
 * Overlay class is used by SuperPosition solver, which is the default solver
 * used for transfer network solver. Therefore, this overlay gets tested most of
 * the time. However, as networks became more complex, new situations occurred
 * and had to be handled, leading to situations where the overlay has to act
 * accordingly to make the simplification in a proper way. This test will put
 * the elements together as the SuperPosition solver would do and recreates
 * difficult scenarios to trigger the more complex algorithms from the overlay
 * simplification process.
 *
 * @author Viktor Alexander Hartung
 */
public class OverlayTest {

    @BeforeClass
    public static void setUpClass() throws Exception {
        // Keep Log out clean during test run
        SimpleLogOut.configureLoggingWarningsOnly();
    }

    public OverlayTest() {
    }

    /**
     * Test of private method checkForBridgedPaths. This test is designed to
     * create a situation that will trigger this method.
     * <p>
     * It occurred on an early debugged case of the makeup system of the rbmk
     * simulation. This is generated by the superposition solver and this test
     * will create the network exactly as the superposition solver did. R3 and
     * R5 are bridged connections which were effort sources previously. The
     * Overlay Has to merge ports n3 to n4 and n5 to n0, this effectively
     * shortens a lot of elements. It failed to build the network at first,
     * therefore this is now a test case to make sure it keeps working.
     */
    @Test
    public void testCheckForBridgedPaths() {
        Overlay instance = new Overlay();

        /*
                        n5  
             ------------o------------
             |           |           |
             X           X           |     R3 and R5 are bridged connections
             X R1        X R4        |     which replaced effort sources.
             X           X           | 
             |           |           |     All other R are 60 Ohms. U will
             o n2        o n4        |     deliver 24 Volts.
             |           |           |
             |          |||         |||    The result will be R0 and R1 in 
            (|) U0      ||| R3      ||| R5 series with 120 Ohms, the R5-bridge
             |          |||         |||    will make R2 and R4 effectively
             |           |           |     useless, generating I = U / R =
             o n1        o n3        |     24 V / 120 Ohms = 0.2 Ampere.
             |           |           |
             X           X           |
             X R0        X R2        |
             X           X           |
             |           |           |
             ------------o------------
                         | n0
                        _|_
         */
        // Generate elements
        GeneralNode[] n = new GeneralNode[6];
        LinearDissipator[] r = new LinearDissipator[6];
        EffortSource u = new EffortSource(PhysicalDomain.ELECTRICAL);
        ClosedOrigin gnd = new ClosedOrigin(PhysicalDomain.ELECTRICAL);

        for (int idx = 0; idx < n.length; idx++) { // init
            n[idx] = new GeneralNode(PhysicalDomain.ELECTRICAL);
            n[idx].setName("n" + idx);
        }

        for (int idx = 0; idx < r.length; idx++) { // init
            r[idx] = new LinearDissipator(PhysicalDomain.ELECTRICAL);
            r[idx].setResistanceParameter(60.0);
            r[idx].setName("R" + idx);
        }
        r[3].setBridgedConnection();
        r[3].setName("R3-Repl");
        r[5].setBridgedConnection();
        r[5].setName("R5-Repl");

        u.setEffort(24);
        u.setName("U");

        // Connect all elements in the exact order as in the debugged real case
        gnd.connectTo(n[0]);
        r[0].connectTo(n[0]);
        r[2].connectTo(n[0]);
        r[5].connectTo(n[0]); // outside bridge

        r[0].connectTo(n[1]);
        u.connectTo(n[1]);
        u.connectTo(n[2]);
        r[1].connectTo(n[2]);
        r[1].connectTo(n[5]);

        r[2].connectTo(n[3]);
        r[3].connectTo(n[3]); // bridge
        r[3].connectTo(n[4]); // bridge
        r[4].connectTo(n[4]);
        r[4].connectTo(n[5]);

        r[5].connectTo(n[5]); // outside bridge

        for (int idx = 0; idx < n.length; idx++) { // init
            instance.registerNode(n[idx]);
        }

        instance.registerElement(gnd, false, false);
        instance.registerElement(r[0], false, false);
        instance.registerElement(u, false, false);
        instance.registerElement(r[1], false, false);
        instance.registerElement(r[2], false, false);
        instance.registerElement(r[3], false, true);
        instance.registerElement(r[4], false, false);
        instance.registerElement(r[5], false, true);

        instance.overlaySetup(); // fails with exception if not working

        instance.prepareCalculation();
        instance.doCalculation();

        assertTrue(instance.isCalculationFinished());
        assertEquals(u.getFlow(), 0.2, 1e-8, "Calculated flow value is wrong.");

        // Change parameters to all open - this occurred when closing all
        // valves and shutting down the pump which was represented by u.
        // A full network calculation must be provided nevertheless.
        u.setEffort(0.0);
        r[0].setOpenConnection();
        r[1].setOpenConnection();
        r[2].setOpenConnection();
        r[4].setOpenConnection();

        instance.prepareCalculation();
        instance.doCalculation();

        // Network must have a complete solution. This will trigger some
        // fancy exceptional cases, but they must provide something.
        assertEquals(u.getFlow(), 0.0, 1e-8,
                "Calculated flow value is not as expected.");
        assertTrue(instance.isCalculationFinished(),
                "No full solution was provided.");
    }

    /**
     * This layer of a superposition solver provided the correct solution but an
     * internal check of one of the resistors failed and reported an illegal
     * effort value difference on a bridged element. This is to further examine
     * the issue.
     */
    @Test
    public void bridgedElementEffortValidation() {
        // instance to test and examine
        Overlay instance = new Overlay();

        // Generate elements
        GeneralNode[] n = new GeneralNode[10];
        LinearDissipator[] r = new LinearDissipator[12];
        EffortSource u = new EffortSource(PhysicalDomain.ELECTRICAL);
        ClosedOrigin gnd = new ClosedOrigin(PhysicalDomain.ELECTRICAL);
        for (int idx = 0; idx < n.length; idx++) { // init
            n[idx] = new GeneralNode(PhysicalDomain.ELECTRICAL);
            n[idx].setName("n" + idx);
        }
        for (int idx = 0; idx < r.length; idx++) { // init
            r[idx] = new LinearDissipator(PhysicalDomain.ELECTRICAL);
            r[idx].setName("R" + idx);
        }

        u.setEffort(19561);
        r[0].setResistanceParameter(1428.57);
        r[1].setOpenConnection();
        r[2].setOpenConnection();
        r[3].setOpenConnection();
        r[4].setBridgedConnection();
        r[5].setBridgedConnection();
        r[6].setOpenConnection();
        r[7].setOpenConnection();
        r[8].setBridgedConnection();
        r[9].setBridgedConnection();
        r[10].setBridgedConnection();
        r[11].setBridgedConnection();

        // build network exactly like it was noted from debugging
        n[0].registerElement(r[0]);
        n[0].registerElement(r[1]);
        n[0].registerElement(r[2]);
        n[0].registerElement(r[3]);
        n[1].registerElement(r[0]);
        n[1].registerElement(u);
        n[2].registerElement(r[1]);
        n[2].registerElement(r[4]);
        n[3].registerElement(r[2]);
        n[3].registerElement(r[5]);
        n[4].registerElement(r[3]);
        n[4].registerElement(r[4]);
        n[4].registerElement(r[5]);
        n[4].registerElement(r[6]);
        n[4].registerElement(r[7]);
        n[5].registerElement(r[6]);
        n[5].registerElement(r[8]);
        n[6].registerElement(r[7]);
        n[6].registerElement(r[9]);
        n[7].registerElement(r[8]);
        n[7].registerElement(r[10]);
        n[8].registerElement(r[9]);
        n[8].registerElement(r[11]);
        n[9].registerElement(u);
        n[9].registerElement(r[10]);
        n[9].registerElement(r[11]);
        n[9].registerElement(gnd);

        gnd.registerNode(n[9]);
        u.registerNode(n[9]);
        u.registerNode(n[1]);
        r[0].registerNode(n[0]);
        r[0].registerNode(n[1]);
        r[1].registerNode(n[2]);
        r[1].registerNode(n[0]);
        r[2].registerNode(n[3]);
        r[2].registerNode(n[0]);
        r[3].registerNode(n[4]);
        r[3].registerNode(n[0]);
        r[4].registerNode(n[2]);
        r[4].registerNode(n[4]);
        r[5].registerNode(n[3]);
        r[5].registerNode(n[4]);
        r[6].registerNode(n[5]);
        r[6].registerNode(n[4]);
        r[7].registerNode(n[6]);
        r[7].registerNode(n[4]);
        r[8].registerNode(n[7]);
        r[8].registerNode(n[5]);
        r[9].registerNode(n[8]);
        r[9].registerNode(n[6]);
        r[10].registerNode(n[9]);
        r[10].registerNode(n[7]);
        r[11].registerNode(n[9]);
        r[11].registerNode(n[8]);

        for (int idx = 0; idx < n.length; idx++) { // init
            instance.registerNode(n[idx]);
        }

        instance.registerElement(r[0], false, false);
        instance.registerElement(u, false, false);
        instance.registerElement(r[1], false, false);
        instance.registerElement(r[2], false, false);
        instance.registerElement(r[3], false, false);
        instance.registerElement(r[4], false, true);
        instance.registerElement(r[5], false, true);
        instance.registerElement(r[6], false, false);
        instance.registerElement(r[7], false, false);
        instance.registerElement(r[8], false, false);
        instance.registerElement(r[9], false, false);
        instance.registerElement(r[10], false, true);
        instance.registerElement(r[11], false, true);
        instance.registerElement(gnd, false, false);

        instance.overlaySetup(); // fails with exception if not working

        instance.prepareCalculation();
        instance.doCalculation();

        assertTrue(instance.isCalculationFinished());

        // Problem: n[2] and n[4] are shorted with r[4] which is set as
        // bridged connection. The effort value is therefor expected to be
        // the same, but it is not. 
        assertEquals(Math.abs(n[2].getEffort() - n[4].getEffort()),
                0.0, 1.0e-4);
    }
}
