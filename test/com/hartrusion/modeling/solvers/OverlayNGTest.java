/*
 * The MIT License
 *
 * Copyright 2025 Viktor Alexander Hartung.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package com.hartrusion.modeling.solvers;

import com.hartrusion.modeling.solvers.Overlay;
import com.hartrusion.modeling.PhysicalDomain;
import com.hartrusion.modeling.general.ClosedOrigin;
import com.hartrusion.modeling.general.EffortSource;
import com.hartrusion.modeling.general.GeneralNode;
import com.hartrusion.modeling.general.LinearDissipator;
import static org.testng.Assert.*;
import org.testng.annotations.Test;

/**
 * Overlay class is used by SuperPosition solver, which is the default solver
 * used for transfer network solver. Therefore this overlay gets tested most
 * of the time. However, as networks became more complex, new situations occured
 * and had to be handled, leading to situations where the overlay has to act
 * accordingly to make the simplification in a proper way. This test will
 * put the elements togehter as the SuperPosition solver would do and recreates
 * difficult scenarios to trigger the more complex algorithms from the overlay
 * simplification process.
 * 
 * @author Viktor Alexander Hartung
 */
public class OverlayNGTest {

    public OverlayNGTest() {
    }

    /**
     * Test of private method checkForBridgedPaths. This test is designed to
     * create a situation that will trigger this method.
     *
     * It occured on a early debugged case of the makeup system of the chernobly
     * simulation. This is generated by the superposition solver and this test
     * will create the network exactly as the superposition solver did. R3 and
     * R5 are bridged connections which were effort sources previously. The
     * Overlay Has to merge ports n3 to n4 and n5 to n0, this efectively
     * shortens a lot of elements. It failed to build the network at first,
     * therefore this is now a test case to make sure it keeps working.
     *
     */
    @Test
    public void testCheckForBridgedPaths() {
        System.out.println("checkForBridgedPaths");
        Overlay instance = new Overlay();

        /*
                        n5  
             ------------o------------
             |           |           |
             X           X           |     R3 and R5 are bridged connections
             X R1        X R4        |     which replaced effort sources.
             X           X           | 
             |           |           |     All other R are 60 Ohms. U will
             o n2        o n4        |     deliver 24 Volts.
             |           |           |
             |          |||         |||    The result will be R0 and R1 in 
            (|) U0      ||| R3      ||| R5 series with 120 Ohms, the R5-bridge
             |          |||         |||    will make R2 and R4 efectively
             |           |           |     useless, generating I = U / R =
             o n1        o n3        |     24 V / 120 Ohms = 0.2 Ampere.
             |           |           |
             X           X           |
             X R0        X R2        |
             X           X           |
             |           |           |
             ------------o------------
                         | n0
                        _|_
         */
        // Generate elements
        GeneralNode[] n = new GeneralNode[6];
        LinearDissipator[] r = new LinearDissipator[6];
        EffortSource u = new EffortSource(PhysicalDomain.ELECTRICAL);
        ClosedOrigin gnd = new ClosedOrigin(PhysicalDomain.ELECTRICAL);

        for (int idx = 0; idx < n.length; idx++) { // init
            n[idx] = new GeneralNode(PhysicalDomain.ELECTRICAL);
            n[idx].setName("n" + idx);
        }

        for (int idx = 0; idx < r.length; idx++) { // init
            r[idx] = new LinearDissipator(PhysicalDomain.ELECTRICAL);
            r[idx].setResistanceParameter(60.0);
            r[idx].setName("R" + idx);
        }
        r[3].setBridgedConnection();
        r[3].setName("R3-Repl");
        r[5].setBridgedConnection();
        r[5].setName("R5-Repl");

        u.setEffort(24);
        u.setName("U");

        // Connect all elements in the exact order as in the debugged real case
        gnd.connectTo(n[0]);
        r[0].connectTo(n[0]);
        r[2].connectTo(n[0]);
        r[5].connectTo(n[0]); // outside bridge

        r[0].connectTo(n[1]);
        u.connectTo(n[1]);
        u.connectTo(n[2]);
        r[1].connectTo(n[2]);
        r[1].connectTo(n[5]);

        r[2].connectTo(n[3]);
        r[3].connectTo(n[3]); // bridge
        r[3].connectTo(n[4]); // bridge
        r[4].connectTo(n[4]);
        r[4].connectTo(n[5]);

        r[5].connectTo(n[5]); // outside bridge

        for (int idx = 0; idx < n.length; idx++) { // init
            instance.registerNode(n[idx]);
        }

        instance.registerElement(gnd, false, false);
        instance.registerElement(r[0], false, false);
        instance.registerElement(u, false, false);
        instance.registerElement(r[1], false, false);
        instance.registerElement(r[2], false, false);
        instance.registerElement(r[3], false, true);
        instance.registerElement(r[4], false, false);
        instance.registerElement(r[5], false, true);

        instance.overlaySetup(); // fails with exception if not working

        instance.prepareCalculation();
        instance.doCalculation();

        assertTrue(instance.isCalculationFinished());
        assertEquals(u.getFlow(), 0.2, 1e-8, "Calculated flow value is wrong.");

        // Change parameters to all open - this occured when closing all
        // valves and shutting down the pump which was represented by u.
        // A full network calculaton must be provided nevertheless.
        u.setEffort(0.0);
        r[0].setOpenConnection();
        r[1].setOpenConnection();
        r[2].setOpenConnection();
        r[4].setOpenConnection();

        instance.prepareCalculation();
        instance.doCalculation();

        // Network must have a complete solution. This will trigger some
        // fancy exceptional cases, but they must provide something.
        assertEquals(u.getFlow(), 0.0, 1e-8,
                "Calculated flow value is not as expected.");
        assertTrue(instance.isCalculationFinished(),
                "No full solution was provided.");
    }

}
